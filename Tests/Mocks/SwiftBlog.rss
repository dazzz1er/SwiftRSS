<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <atom:link href="http://developer.apple.com/swift/blog/news.rss" rel="self" type="application/rss+xml" />
        <title>Swift Blog - Apple Developer</title>
        <link>http://developer.apple.com/swift/blog/</link>
        <description>Get the latest news and helpful tips on the Swift programming language from the engineers who created it.</description>
        <language>en-US</language>
        <lastBuildDate>Thu, 25 Sep 2014 10:00:00 PDT</lastBuildDate>
        <generator>Custom</generator>
        <copyright>Copyright 2014, Apple Inc.</copyright>
        
        <item>
            <title>Building  assert()  in Swift, Part 2:  __FILE__  and  __LINE__ </title>
            <link>http://developer.apple.com/swift/blog/?id=15</link>
            <guid>http://developer.apple.com/swift/blog/?id=15</guid>
            <description> Two occasionally useful features of C are the  __FILE__  and  __LINE__  magic macros. These are built into the preprocessor, and expanded out before the C parser is run. Despite not having a preprocessor, Swift provides very similar functionality with similar names, but Swift works quite differently under the covers.  Built-In Identifiers  As described in  the Swift programming guide , Swift has a number of built-in identifiers, including   __FILE__ ,  __LINE__ ,  __COLUMN__ , and  __FUNCTION__ . These expressions can be used anywhere and are expanded by the parser to string or integer literals that correspond to the current location in the source code. This is incredibly useful for manual logging, e.g. to print out the current position before quitting.  However, this doesn’t help us in our quest to implement  assert() .  If we defined assert like this:  [view code in blog]  The above code would print out of the file/line location that implements  assert()  itself, not the location from the caller. That isn’t helpful.  Getting the location of a caller  Swift borrows a clever feature from the D language: these identifiers expand to the location of the caller  when evaluated in a default argument list .  To enable this behavior, the  assert()  function is defined something like this:  [view code in blog]  The second parameter to the Swift  assert()  function is an optional string that you can specify, and the third and forth arguments are defaulted to be the position in the caller’s context.  This allows  assert()  to pick up the source location of the caller by default, and if you want to define your own abstractions on top of assert, you can pass down locations from its caller.  As a trivial example, you could define a function that logs and asserts like this:  [view code in blog]  This properly propagates the file/line location of the  logAndAssert()  caller down to the implementation of  assert() . Note that  StaticString , as shown in the code above, is a simple  String-like  type used to store a string literal, such as one produced by  __FILE__ , with no  memory-management  overhead.  In addition to being useful for  assert() , this functionality is used in the Swift implementation of the higher-level XCTest framework, and may be useful for your own libraries as well. </description>
            <pubDate>Thu, 25 Sep 2014 10:00:00 PDT</pubDate>
            <content:encoded><![CDATA[<p>Two occasionally useful features of C are the <span class="keyword">__FILE__</span> and <span class="keyword">__LINE__</span> magic macros. These are built into the preprocessor, and expanded out before the C parser is run. Despite not having a preprocessor, Swift provides very similar functionality with similar names, but Swift works quite differently under the covers.</p><h3>Built-In Identifiers</h3><p>As described in <a href="http://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/LexicalStructure.html">the Swift programming guide</a>, Swift has a number of built-in identifiers, including  <span class="keyword">__FILE__</span>, <span class="keyword">__LINE__</span>, <span class="keyword">__COLUMN__</span>, and <span class="keyword">__FUNCTION__</span>. These expressions can be used anywhere and are expanded by the parser to string or integer literals that correspond to the current location in the source code. This is incredibly useful for manual logging, e.g. to print out the current position before quitting.</p><p>However, this doesn’t help us in our quest to implement <span class="keyword">assert()</span>.  If we defined assert like this:</p><a href="http://developer.apple.com/swift/blog/?id=15">[view code in blog]</a><p>The above code would print out of the file/line location that implements <span class="keyword">assert()</span> itself, not the location from the caller. That isn’t helpful.</p><h3>Getting the location of a caller</h3><p>Swift borrows a clever feature from the D language: these identifiers expand to the location of the caller <em>when evaluated in a default argument list</em>.  To enable this behavior, the <span class="keyword">assert()</span> function is defined something like this:</p><a href="http://developer.apple.com/swift/blog/?id=15">[view code in blog]</a><p>The second parameter to the Swift <span class="keyword">assert()</span> function is an optional string that you can specify, and the third and forth arguments are defaulted to be the position in the caller’s context.  This allows <span class="keyword">assert()</span> to pick up the source location of the caller by default, and if you want to define your own abstractions on top of assert, you can pass down locations from its caller.  As a trivial example, you could define a function that logs and asserts like this:</p><a href="http://developer.apple.com/swift/blog/?id=15">[view code in blog]</a><p>This properly propagates the file/line location of the <span class="keyword">logAndAssert()</span> caller down to the implementation of <span class="keyword">assert()</span>. Note that <span class="keyword">StaticString</span>, as shown in the code above, is a simple <span class="nowrap">String-like</span> type used to store a string literal, such as one produced by <span class="keyword">__FILE__</span>, with no <span class="nowrap">memory-management</span> overhead.</p><p>In addition to being useful for <span class="keyword">assert()</span>, this functionality is used in the Swift implementation of the higher-level XCTest framework, and may be useful for your own libraries as well.</p>]]></content:encoded>
        </item>
        <item>
            <title>Swift Has Reached 1.0</title>
            <link>http://developer.apple.com/swift/blog/?id=14</link>
            <guid>http://developer.apple.com/swift/blog/?id=14</guid>
            <description> On June 2, 2014 at WWDC, the Swift team finally showed you what we had been working on for years. That was a  big day with lots of excitement, for us and for developers around the world. Today, we’ve reached the second giant milestone:  Swift version 1.0 is now GM.  You can now submit your apps that use Swift to the App Store. Whether your app uses Swift for a small feature or a complete application, now is the time to share your app with the world. It’s your turn to excite everyone with your new creations.  Swift for OS X  Today is the GM date for Swift on iOS. We have one more GM date to go for Mac. Swift for OS X currently requires the SDK for OS X Yosemite, and when Yosemite ships later this fall, Swift will also be GM on the Mac. In the meantime, you can keep developing your Mac apps with Swift by downloading the beta of  Xcode 6.1 .  The Road Ahead  You’ll notice we’re using the word “GM”, not “final”. That’s because Swift will continue to advance with new features, improved performance, and refined syntax. In fact, you can expect a few improvements to come in Xcode 6.1 in time for the Yosemite launch. Because your apps today embed a version of the Swift GM runtime, they will continue to run well into the future. </description>
            <pubDate>Tue, 09 Sep 2014 11:00:00 PDT</pubDate>
            <content:encoded><![CDATA[<p>On June 2, 2014 at WWDC, the Swift team finally showed you what we had been working on for years. That was a  big day with lots of excitement, for us and for developers around the world. Today, we’ve reached the second giant milestone:</p><p>Swift version 1.0 is now GM.</p><p>You can now submit your apps that use Swift to the App Store. Whether your app uses Swift for a small feature or a complete application, now is the time to share your app with the world. It’s your turn to excite everyone with your new creations.</p><h3>Swift for OS X</h3><p>Today is the GM date for Swift on iOS. We have one more GM date to go for Mac. Swift for OS X currently requires the SDK for OS X Yosemite, and when Yosemite ships later this fall, Swift will also be GM on the Mac. In the meantime, you can keep developing your Mac apps with Swift by downloading the beta of <a href="http://developer.apple.com/xcode/downloads/">Xcode 6.1</a>.</p><h3>The Road Ahead</h3><p>You’ll notice we’re using the word “GM”, not “final”. That’s because Swift will continue to advance with new features, improved performance, and refined syntax. In fact, you can expect a few improvements to come in Xcode 6.1 in time for the Yosemite launch. Because your apps today embed a version of the Swift GM runtime, they will continue to run well into the future.</p>]]></content:encoded>
        </item>
        <item>
            <title>Patterns Playground</title>
            <link>http://developer.apple.com/swift/blog/?id=13</link>
            <guid>http://developer.apple.com/swift/blog/?id=13</guid>
            <description> In Swift, a pattern is a way to describe and match a set of values based on certain rules, such as:    All tuples whose first value is 0  All numbers in the range 1...5  All class instances of a certain type   The learning playground linked below includes embedded documentation and experiments for you to perform. Download it for an interactive experience that will give you a jump start into using patterns in your own apps.  This playground requires the latest beta version of Xcode 6 on OS X Mavericks or OS X Yosemite beta. </description>
            <pubDate>Wed, 03 Sep 2014 09:00:00 PDT</pubDate>
            <content:encoded><![CDATA[<p>In Swift, a pattern is a way to describe and match a set of values based on certain rules, such as: </p><ul class="tight"><li>All tuples whose first value is 0</li><li>All numbers in the range 1...5</li><li>All class instances of a certain type</li></ul><p>The learning playground linked below includes embedded documentation and experiments for you to perform. Download it for an interactive experience that will give you a jump start into using patterns in your own apps.</p><p>This playground requires the latest beta version of Xcode 6 on OS X Mavericks or OS X Yosemite beta.</p>]]></content:encoded>
        </item>
        <item>
            <title>Optionals Case Study:  valuesForKeys </title>
            <link>http://developer.apple.com/swift/blog/?id=12</link>
            <guid>http://developer.apple.com/swift/blog/?id=12</guid>
            <description> This post explores how optionals help preserve strong type safety within Swift. We’re going to create a Swift version of an Objective-C API. Swift doesn’t really need this API, but it makes for a fun example.  In Objective-C,  NSDictionary  has a method  -objectsForKeys:notFoundMarker:  that takes an  NSArray  of keys, and returns an  NSArray  of corresponding values. From the documentation: “the  N -th object in the returned array corresponds to the  N -th key in [the input parameter] keys.” What if the third key isn’t actually in the dictionary? That’s where the  notFoundMarker  parameter comes in. The third element in the array will be this marker object rather than a value from the dictionary. The Foundation framework even provides a class for this case if you don’t have another to use:  NSNull .  In Swift, the  Dictionary  type doesn’t have an  objectsForKeys  equivalent. For this exercise, we’re going to add one — as  valuesForKeys  in keeping with the common use of ‘value’ in Swift — using an extension:  [view code in blog]  This is where our new implementation in Swift will differ from Objective-C. In Swift, the stronger typing restricts the resulting array to contain only a single type of element — we can’t put  NSNull  in an array of strings. However, Swift gives an even better option: we can return an  array of optionals . All our values get wrapped in optionals, and instead of  NSNull , we just use  nil .  [view code in blog]  NOTE: Some of you may have guessed why a Swift  Dictionary  doesn’t need this API, and already imagined something like this:  [view code in blog]  This has the exact same effect as the imperative version above, but all of the boilerplate has been wrapped up in the call to  map . This is great example why Swift types often have a small API surface area, because it’s so easy to just call  map  directly.  Now we can try out some examples:  [view code in blog]  Nested Optionals  Now, what if we asked for the  last  element of each result?  [view code in blog]  That’s strange — we have two levels of  Optional  in the first case, and  Optional(nil)  in the second case. What’s going on?  Remember the declaration of the  last  property:  [view code in blog]  This says that the  last  property’s type is an  Optional  version of the array’s element type. In  this  case, the element type is also optional ( String? ). So we end up with  String?? , a doubly-nested optional type.  So what does  Optional(nil)  mean?  Recall that in Objective-C we were going to use  NSNull  as a placeholder. The Objective-C version of these three calls looks like this:  [view code in blog]  In both the Swift and Objective-C cases, a return value of  nil  means “the array is empty, therefore there’s no last element.” The return value of  Optional(nil)  (or in Objective-C  NSNull ) means “the last element of this array exists, but it represents an absence.” Objective-C has to rely on a placeholder object to do this, but Swift can represent it in the type system.  Providing a Default  To wrap up, what if you  did  want to provide a default value for anything that wasn’t in the dictionary? Well, that’s easy enough.  [view code in blog]  While Objective-C has to rely on a placeholder object to do this, Swift can represent it in the type system, and provides rich syntactic support for handling optional results. </description>
            <pubDate>Tue, 26 Aug 2014 14:00:00 PDT</pubDate>
            <content:encoded><![CDATA[<p>This post explores how optionals help preserve strong type safety within Swift. We’re going to create a Swift version of an Objective-C API. Swift doesn’t really need this API, but it makes for a fun example.</p><p>In Objective-C, <span class="keyword">NSDictionary</span> has a method <span class="keyword">-objectsForKeys:notFoundMarker:</span> that takes an <span class="keyword">NSArray</span> of keys, and returns an <span class="keyword">NSArray</span> of corresponding values. From the documentation: “the <em>N</em>-th object in the returned array corresponds to the <em>N</em>-th key in [the input parameter] keys.” What if the third key isn’t actually in the dictionary? That’s where the <span class="keyword">notFoundMarker</span> parameter comes in. The third element in the array will be this marker object rather than a value from the dictionary. The Foundation framework even provides a class for this case if you don’t have another to use: <span class="keyword">NSNull</span>.</p><p>In Swift, the <span class="keyword">Dictionary</span> type doesn’t have an <span class="keyword">objectsForKeys</span> equivalent. For this exercise, we’re going to add one — as <span class="keyword">valuesForKeys</span> in keeping with the common use of ‘value’ in Swift — using an extension:</p><a href="http://developer.apple.com/swift/blog/?id=12">[view code in blog]</a><p>This is where our new implementation in Swift will differ from Objective-C. In Swift, the stronger typing restricts the resulting array to contain only a single type of element — we can’t put <span class="keyword">NSNull</span> in an array of strings. However, Swift gives an even better option: we can return an <emn>array of optionals</em>. All our values get wrapped in optionals, and instead of <span class="keyword">NSNull</span>, we just use <span class="keyword">nil</span>.</p><a href="http://developer.apple.com/swift/blog/?id=12">[view code in blog]</a><p>NOTE: Some of you may have guessed why a Swift <span class="keyword">Dictionary</span> doesn’t need this API, and already imagined something like this:</p><a href="http://developer.apple.com/swift/blog/?id=12">[view code in blog]</a><p>This has the exact same effect as the imperative version above, but all of the boilerplate has been wrapped up in the call to <span class="keyword">map</span>. This is great example why Swift types often have a small API surface area, because it’s so easy to just call <span class="keyword">map</span> directly.</p><p>Now we can try out some examples:</p><a href="http://developer.apple.com/swift/blog/?id=12">[view code in blog]</a><h3>Nested Optionals</h3><p>Now, what if we asked for the <span class="keyword">last</span> element of each result?</p><a href="http://developer.apple.com/swift/blog/?id=12">[view code in blog]</a><p>That’s strange — we have two levels of <span class="keyword">Optional</span> in the first case, and <span class="keyword">Optional(nil)</span> in the second case. What’s going on?</p><p>Remember the declaration of the <span class="keyword">last</span> property:</p><a href="http://developer.apple.com/swift/blog/?id=12">[view code in blog]</a><p>This says that the <span class="keyword">last</span> property’s type is an <span class="keyword">Optional</span> version of the array’s element type. In <em>this</em> case, the element type is also optional (<span class="keyword">String?</span>). So we end up with <span class="keyword">String??</span>, a doubly-nested optional type.</p><p>So what does <span class="keyword">Optional(nil)</span> mean?</p><p>Recall that in Objective-C we were going to use <span class="keyword">NSNull</span> as a placeholder. The Objective-C version of these three calls looks like this:</p><a href="http://developer.apple.com/swift/blog/?id=12">[view code in blog]</a><p>In both the Swift and Objective-C cases, a return value of <span class="keyword">nil</span> means “the array is empty, therefore there’s no last element.” The return value of <span class="keyword">Optional(nil)</span> (or in Objective-C <span class="keyword">NSNull</span>) means “the last element of this array exists, but it represents an absence.” Objective-C has to rely on a placeholder object to do this, but Swift can represent it in the type system.</p><h3>Providing a Default</h3><p>To wrap up, what if you <em>did</em> want to provide a default value for anything that wasn’t in the dictionary? Well, that’s easy enough.</p><a href="http://developer.apple.com/swift/blog/?id=12">[view code in blog]</a><p>While Objective-C has to rely on a placeholder object to do this, Swift can represent it in the type system, and provides rich syntactic support for handling optional results.</p>]]></content:encoded>
        </item>
        <item>
            <title>Access Control and  protected </title>
            <link>http://developer.apple.com/swift/blog/?id=11</link>
            <guid>http://developer.apple.com/swift/blog/?id=11</guid>
            <description> The response to support for access control in Swift has been extremely positive. However, some developers have been asking, “Why doesn’t Swift have something like  protected ?” Many other programming languages have an access control option that restricts certain methods from being accessed from anywhere except subclasses.  When designing access control levels in Swift, we considered two main use cases:   keep  private  details of a class hidden from the rest of the app  keep  internal  details of a framework hidden from the client app   These correspond to  private  and  internal  levels of access, respectively.  In contrast,  protected  conflates access with inheritance, adding an entirely new control axis to reason about. It doesn’t actually offer any real protection, since a subclass can always expose “protected” API through a new public method or property. It doesn’t offer  additional optimization opportunities either, since new overrides can come from anywhere. And it’s unnecessarily restrictive — it allows subclasses, but not any of the subclass’s helpers, to access something.  As some developers have pointed out, Apple frameworks do occasionally separate parts of API intended for use by subclasses. Wouldn’t  protected  be helpful here? Upon inspection, these methods generally fall into one of two groups. First, methods that aren’t really useful outside the subclass, so protection isn’t critical (and recall the helper case above). Second, methods that are designed to be overridden but not called. An example is  drawRect(_:) , which is certainly used within the UIKit codebase but is not to be called outside UIKit.  It’s also not clear how  protected  should interact with extensions. Does an extension to a class have access to that class’s protected members? Does an extension to a subclass have access to the superclass’s protected members? Does it make a difference if the extension is declared in the same module as the class?  There was one other influence that led us to the current design: existing practices of Objective-C developers both inside and outside of Apple. Objective-C methods and properties are generally declared in a public header (.h) file, but can also be added in class extensions within the implementation (.m) file. When parts of a public class are intended for use elsewhere within the framework but not outside, developers create a second header file with the class’s “internal” bits. These three levels of access correspond to  public ,  private , and  internal  in Swift.  Swift provides access control along a single, easy-to-understand axis, unrelated to inheritance. We believe this model is simpler, and provides access control the way it is most often needed: to isolate implementation details to within a class or within a framework. It may be different from what you’ve used before, but we encourage you to try it out. </description>
            <pubDate>Tue, 19 Aug 2014 10:00:00 PDT</pubDate>
            <content:encoded><![CDATA[<p>The response to support for access control in Swift has been extremely positive. However, some developers have been asking, “Why doesn’t Swift have something like <span class="keyword">protected</span>?” Many other programming languages have an access control option that restricts certain methods from being accessed from anywhere except subclasses.</p><p>When designing access control levels in Swift, we considered two main use cases:</p><ul class="tight"><li>keep <span class="keyword">private</span> details of a class hidden from the rest of the app</li><li>keep <span class="keyword">internal</span> details of a framework hidden from the client app</li></ul><p>These correspond to <span class="keyword">private</span> and <span class="keyword">internal</span> levels of access, respectively.</p><p>In contrast, <span class="keyword">protected</span> conflates access with inheritance, adding an entirely new control axis to reason about. It doesn’t actually offer any real protection, since a subclass can always expose “protected” API through a new public method or property. It doesn’t offer  additional optimization opportunities either, since new overrides can come from anywhere. And it’s unnecessarily restrictive — it allows subclasses, but not any of the subclass’s helpers, to access something.</p><p>As some developers have pointed out, Apple frameworks do occasionally separate parts of API intended for use by subclasses. Wouldn’t <span class="keyword">protected</span> be helpful here? Upon inspection, these methods generally fall into one of two groups. First, methods that aren’t really useful outside the subclass, so protection isn’t critical (and recall the helper case above). Second, methods that are designed to be overridden but not called. An example is <span class="keyword">drawRect(_:)</span>, which is certainly used within the UIKit codebase but is not to be called outside UIKit.</p><p>It’s also not clear how <span class="keyword">protected</span> should interact with extensions. Does an extension to a class have access to that class’s protected members? Does an extension to a subclass have access to the superclass’s protected members? Does it make a difference if the extension is declared in the same module as the class?</p><p>There was one other influence that led us to the current design: existing practices of Objective-C developers both inside and outside of Apple. Objective-C methods and properties are generally declared in a public header (.h) file, but can also be added in class extensions within the implementation (.m) file. When parts of a public class are intended for use elsewhere within the framework but not outside, developers create a second header file with the class’s “internal” bits. These three levels of access correspond to <span class="keyword">public</span>, <span class="keyword">private</span>, and <span class="keyword">internal</span> in Swift.</p><p>Swift provides access control along a single, easy-to-understand axis, unrelated to inheritance. We believe this model is simpler, and provides access control the way it is most often needed: to isolate implementation details to within a class or within a framework. It may be different from what you’ve used before, but we encourage you to try it out.</p>]]></content:encoded>
        </item>
        <item>
            <title>Value and Reference Types</title>
            <link>http://developer.apple.com/swift/blog/?id=10</link>
            <guid>http://developer.apple.com/swift/blog/?id=10</guid>
            <description> Types in Swift fall into one of two categories: first, “value types”, where each instance keeps a unique copy of its data, usually defined as a  struct ,  enum , or tuple. The second, “reference types”, where instances share a single copy of the data, and the type is usually defined as a  class . In this post we explore the merits of value and reference types, and how to choose between them.     What’s the Difference?    The most basic distinguishing feature of a  value type  is that copying — the effect of assignment, initialization, and argument passing — creates an  independent instance  with its own unique copy of its data:   [view code in blog]   Copying a reference, on the other hand, implicitly creates a shared instance. After a copy, two variables then refer to a single instance of the data, so modifying data in the second variable also affects the original, e.g.:   [view code in blog]   The Role of Mutation in Safety   One of the primary reasons to choose value types over reference types is the ability to more easily reason about your code. If you always get a unique, copied instance, you can trust that no other part of your app is changing the data under the covers. This is especially helpful in multi-threaded environments where a different thread could alter your data out from under you. This can create nasty bugs that are extremely hard to debug.   Because the difference is defined in terms of what happens when you change data, there’s one case where value and reference types overlap: when instances have no writable data. In the absence of mutation, values and references act exactly the same way.   You may be thinking that it could be valuable, then, to have a case where a  class  is completely immutable. This would make it easier to use Cocoa  NSObject  objects, while maintaining the benefits of value semantics. Today, you can write an immutable class in Swift by using only immutable stored properties and avoiding exposing any APIs that can modify state. In fact, many common Cocoa classes, such as  NSURL , are designed as immutable classes. However, Swift does not currently provide any language mechanism to enforce  class  immutability (e.g. on subclasses) the way it enforces immutability for  struct  and  enum .   How to Choose?   So if you want to build a new type, how do you decide which kind to make? When you’re working with Cocoa, many APIs expect subclasses of  NSObject , so you have to use a  class . For the other cases, here are some guidelines:   Use a value type when:     Comparing instance data with  ==  makes sense   You want copies to have independent state   The data will be used in code across multiple threads     Use a reference type (e.g. use a  class ) when:     Comparing instance identity with  ===  makes sense   You want to create shared, mutable state     In Swift,  Array ,  String , and  Dictionary  are all value types. They behave much like a simple  int  value in C, acting as a unique instance of that data. You don’t need to do anything special — such as making an explicit copy — to prevent other code from modifying that data behind your back. Importantly, you can safely pass copies of values across threads without synchronization. In the spirit of improving safety, this model will help you write more predictable code in Swift. </description>
            <pubDate>Fri, 15 Aug 2014 13:30:00 PDT</pubDate>
            <content:encoded><![CDATA[<p>Types in Swift fall into one of two categories: first, “value types”, where each instance keeps a unique copy of its data, usually defined as a <span class="keyword">struct</span>, <span class="keyword">enum</span>, or tuple. The second, “reference types”, where instances share a single copy of the data, and the type is usually defined as a <span class="keyword">class</span>. In this post we explore the merits of value and reference types, and how to choose between them. </p> <h3> What’s the Difference? </h3> <p>The most basic distinguishing feature of a <em>value type</em> is that copying — the effect of assignment, initialization, and argument passing — creates an <em>independent instance</em> with its own unique copy of its data:</p> <a href="http://developer.apple.com/swift/blog/?id=10">[view code in blog]</a> <p>Copying a reference, on the other hand, implicitly creates a shared instance. After a copy, two variables then refer to a single instance of the data, so modifying data in the second variable also affects the original, e.g.:</p> <a href="http://developer.apple.com/swift/blog/?id=10">[view code in blog]</a> <h3>The Role of Mutation in Safety</h3> <p>One of the primary reasons to choose value types over reference types is the ability to more easily reason about your code. If you always get a unique, copied instance, you can trust that no other part of your app is changing the data under the covers. This is especially helpful in multi-threaded environments where a different thread could alter your data out from under you. This can create nasty bugs that are extremely hard to debug.</p> <p>Because the difference is defined in terms of what happens when you change data, there’s one case where value and reference types overlap: when instances have no writable data. In the absence of mutation, values and references act exactly the same way.</p> <p>You may be thinking that it could be valuable, then, to have a case where a <span class="keyword">class</span> is completely immutable. This would make it easier to use Cocoa <span class="keyword">NSObject</span> objects, while maintaining the benefits of value semantics. Today, you can write an immutable class in Swift by using only immutable stored properties and avoiding exposing any APIs that can modify state. In fact, many common Cocoa classes, such as <span class="keyword">NSURL</span>, are designed as immutable classes. However, Swift does not currently provide any language mechanism to enforce <span class="keyword">class</span> immutability (e.g. on subclasses) the way it enforces immutability for <span class="keyword">struct</span> and <span class="keyword">enum</span>.</p> <h3>How to Choose?</h3> <p>So if you want to build a new type, how do you decide which kind to make? When you’re working with Cocoa, many APIs expect subclasses of <span class="keyword">NSObject</span>, so you have to use a <span class="keyword">class</span>. For the other cases, here are some guidelines:</p> <p>Use a value type when:</p> <ul class="tight"> <li>Comparing instance data with <span class="keyword">==</span> makes sense</li> <li>You want copies to have independent state</li> <li>The data will be used in code across multiple threads</li> </ul> <p>Use a reference type (e.g. use a <span class="keyword">class</span>) when:</p> <ul class="tight"> <li>Comparing instance identity with <span class="keyword">===</span> makes sense</li> <li>You want to create shared, mutable state</li> </ul> <p>In Swift, <span class="keyword">Array</span>, <span class="keyword">String</span>, and <span class="keyword">Dictionary</span> are all value types. They behave much like a simple <span class="keyword">int</span> value in C, acting as a unique instance of that data. You don’t need to do anything special — such as making an explicit copy — to prevent other code from modifying that data behind your back. Importantly, you can safely pass copies of values across threads without synchronization. In the spirit of improving safety, this model will help you write more predictable code in Swift.</p>]]></content:encoded>
        </item>
        <item>
            <title>Balloons</title>
            <link>http://developer.apple.com/swift/blog/?id=9</link>
            <guid>http://developer.apple.com/swift/blog/?id=9</guid>
            <description> Many people have asked about the Balloons playground we demonstrated when introducing Swift at WWDC. Balloons shows that writing code can be interactive and fun, while presenting several great features of playgrounds. Now you can learn how the special effects were done with this tutorial version of ‘Balloons.playground’, which includes documentation and suggestions for experimentation.  This playground uses new features of SpriteKit and requires the latest beta versions of Xcode 6 and  OS X Yosemite . </description>
            <pubDate>Fri, 08 Aug 2014 11:00:00 PDT</pubDate>
            <content:encoded><![CDATA[<p>Many people have asked about the Balloons playground we demonstrated when introducing Swift at WWDC. Balloons shows that writing code can be interactive and fun, while presenting several great features of playgrounds. Now you can learn how the special effects were done with this tutorial version of ‘Balloons.playground’, which includes documentation and suggestions for experimentation.</p><p>This playground uses new features of SpriteKit and requires the latest beta versions of Xcode 6 and <span class="nowrap">OS X Yosemite</span>.</p>]]></content:encoded>
        </item>
        <item>
            <title>Boolean</title>
            <link>http://developer.apple.com/swift/blog/?id=8</link>
            <guid>http://developer.apple.com/swift/blog/?id=8</guid>
            <description> The boolean  Bool  type in Swift underlies a lot of primitive functionality, making it an interesting demonstration of how to build a simple type. This post walks through the creation of a new  MyBool  type designed and implemented to be very similar to the  Bool  type built into Swift. We hope this walk through the design of a simple Swift type will help you better understand how the language works.   Let’s start with the basic definition. The  MyBool  type models two different cases, perfect for an enum:   [view code in blog]   To reduce confusion in this post, we’ve named the cases  myTrue  and  myFalse . We want  MyBool()  to produce a false value, and can do so by providing an  init  method:   [view code in blog]   Swift enum declarations implicitly scope their enumerators within their body, allowing us to refer to  MyBool.myFalse  and even  .myFalse  when a contextual type is available.  However, we want our type to work with the primitive  true  and  false  literal keywords. To make this work, we can make  MyBool  conform to the  BooleanLiteralConvertible  protocol like this:   [view code in blog]   With this set up, we have our basic type, but we still can’t do much with it.  Booleans need to be testable within an  if  condition.  Swift models this with the  BooleanType  protocol, which allows any type to be used as a logical condition:   [view code in blog]   We also want anything that conforms to  BooleanType  to be castable to  MyBool , so we add:   [view code in blog]   Note that the use of  _  in the initializer argument list disables the keyword argument, which allows the  MyBool(x)  syntax to be used instead of requiring  MyBool(v: x) .   Now that we have basic functionality, let’s define some operators to work with it, starting with the  ==  operator.  Simple enums that have no associated data (like  MyBool ) are automatically made  Equatable  by the compiler, so no additional code is required. However, you can make arbitrary types equatable by conforming to the  Equatable  protocol and implementing the  ==  operator. If  MyBool  weren’t already  Equatable , this would look like this:   [view code in blog]   Here we’re using some simple pattern matching in the  switch  statement to handle this. Since  MyBool  is now  Equatable , we get a free implementation of the  !=  operator.  Lets add binary operations:   [view code in blog]   With the basic operators in place, we can implement a variety of helpful unary and compound assignment operators as well, for example:   [view code in blog]   The  &amp;=  operator takes the left operand as  inout  because it reads and writes to it, and the effect must be visible to the user of the operator.  Swift gives you complete control over mutability of operations on value types like  enum  and  struct .   With this, the simple  MyBool  type has all of the basic operations and operators.  Hopefully this post gives you a few tips that you can apply to your own code when defining higher-level types. </description>
            <pubDate>Tue, 05 Aug 2014 17:00:00 PDT</pubDate>
            <content:encoded><![CDATA[<p>The boolean <span class="keyword">Bool</span> type in Swift underlies a lot of primitive functionality, making it an interesting demonstration of how to build a simple type. This post walks through the creation of a new <span class="keyword">MyBool</span> type designed and implemented to be very similar to the <span class="keyword">Bool</span> type built into Swift. We hope this walk through the design of a simple Swift type will help you better understand how the language works.</p> <p>Let’s start with the basic definition. The <span class="keyword">MyBool</span> type models two different cases, perfect for an enum:</p> <a href="http://developer.apple.com/swift/blog/?id=8">[view code in blog]</a> <p>To reduce confusion in this post, we’ve named the cases <span class="keyword">myTrue</span> and <span class="keyword">myFalse</span>. We want <span class="keyword">MyBool()</span> to produce a false value, and can do so by providing an <span class="keyword">init</span> method:</p> <a href="http://developer.apple.com/swift/blog/?id=8">[view code in blog]</a> <p>Swift enum declarations implicitly scope their enumerators within their body, allowing us to refer to <span class="keyword">MyBool.myFalse</span> and even <span class="keyword">.myFalse</span> when a contextual type is available.  However, we want our type to work with the primitive <span class="keyword">true</span> and <span class="keyword">false</span> literal keywords. To make this work, we can make <span class="keyword">MyBool</span> conform to the <span class="keyword">BooleanLiteralConvertible</span> protocol like this:</p> <a href="http://developer.apple.com/swift/blog/?id=8">[view code in blog]</a> <p>With this set up, we have our basic type, but we still can’t do much with it.  Booleans need to be testable within an <span class="keyword">if</span> condition.  Swift models this with the <span class="keyword">BooleanType</span> protocol, which allows any type to be used as a logical condition:</p> <a href="http://developer.apple.com/swift/blog/?id=8">[view code in blog]</a> <p>We also want anything that conforms to <span class="keyword">BooleanType</span> to be castable to <span class="keyword">MyBool</span>, so we add:</p> <a href="http://developer.apple.com/swift/blog/?id=8">[view code in blog]</a> <p>Note that the use of <span class="keyword">_</span> in the initializer argument list disables the keyword argument, which allows the <span class="keyword">MyBool(x)</span> syntax to be used instead of requiring <span class="keyword">MyBool(v: x)</span>.</p> <p>Now that we have basic functionality, let’s define some operators to work with it, starting with the <span class="keyword">==</span> operator.  Simple enums that have no associated data (like <span class="keyword">MyBool</span>) are automatically made <span class="keyword">Equatable</span> by the compiler, so no additional code is required. However, you can make arbitrary types equatable by conforming to the <span class="keyword">Equatable</span> protocol and implementing the <span class="keyword">==</span> operator. If <span class="keyword">MyBool</span> weren’t already <span class="keyword">Equatable</span>, this would look like this:</p> <a href="http://developer.apple.com/swift/blog/?id=8">[view code in blog]</a> <p>Here we’re using some simple pattern matching in the <span class="keyword">switch</span> statement to handle this. Since <span class="keyword">MyBool</span> is now <span class="keyword">Equatable</span>, we get a free implementation of the <span class="keyword">!=</span> operator.  Lets add binary operations:</p> <a href="http://developer.apple.com/swift/blog/?id=8">[view code in blog]</a> <p>With the basic operators in place, we can implement a variety of helpful unary and compound assignment operators as well, for example:</p> <a href="http://developer.apple.com/swift/blog/?id=8">[view code in blog]</a> <p>The <span class="keyword">&amp;=</span> operator takes the left operand as <span class="keyword">inout</span> because it reads and writes to it, and the effect must be visible to the user of the operator.  Swift gives you complete control over mutability of operations on value types like <span class="keyword">enum</span> and <span class="keyword">struct</span>.</p> <p>With this, the simple <span class="keyword">MyBool</span> type has all of the basic operations and operators.  Hopefully this post gives you a few tips that you can apply to your own code when defining higher-level types.</p>]]></content:encoded>
        </item>
        <item>
            <title>Files and Initialization</title>
            <link>http://developer.apple.com/swift/blog/?id=7</link>
            <guid>http://developer.apple.com/swift/blog/?id=7</guid>
            <description>  By now, most of you have written a small Swift app or experimented in the playground. You may even have experienced an error after you copied code from a playground into another file and wondered, “What is actually going on? What is the difference between a playground file, and other Swift source files?” This post will explain how Swift deals with the files in your project, and how global data is initialized.   Files in an App   A Swift app is composed of any number of files, each with the functions, classes, and other declarations that make up the app. Most Swift files in your app are  order-independent , meaning you can use a type before it is defined, and can even import modules at the bottom of the file (although that is not recommended Swift style.)   However, top-level code is not allowed in most of your Swift source files. For clarity, any executable statement not written within a function body, within a class, or otherwise encapsulated is considered top-level. We have this rule because if top-level code were allowed in all your files, it would be hard to determine where to start the program.   Playgrounds, REPL, and Top-Level Code   You may be wondering why the code below works perfectly in a playground. This example isn’t encapsulated in anything, so it must be top-level code:   [view code in blog]   The above single-line program works — with no additional code at all — because playground files do support the execution of top-level code. Code within a playground file is  order-dependent , run in top-down lexical order. For example, you can’t use a type before you define it. Of course, Swift playground files can also define functions, classes, and any other legal Swift code, but they don’t need to.  This makes it easy to learn the Swift language or try a new API without writing a lot of code to get started.   In addition to playgrounds, top-level code can also be run in the REPL (Read-Eval-Print-Loop) or when launching Swift files as scripts. To use Swift for scripting, you can use shebang-style launching by starting your Swift file with “#!/usr/bin/xcrun swift” or type “xcrun swift myFile.swift” within Terminal.   Application Entry Points and “main.swift”   You’ll notice that earlier we said top-level code isn’t allowed in  most  of your app’s source files. The exception is a special file named “main.swift”, which behaves much like a playground file, but is built with your app’s source code. The “main.swift” file can contain top-level code, and the order-dependent rules apply as well. In effect, the first line of code to run in “main.swift” is implicitly defined as the main entrypoint for the program. This allows the minimal Swift program to be a single line — as long as that line is in “main.swift”.   In Xcode, Mac templates default to including a “main.swift” file, but for iOS apps the default for new iOS project templates is to add  @UIApplicationMain  to a regular Swift file. This causes the compiler to synthesize a  main  entry point for your iOS app, and eliminates the need for a “main.swift” file.   Alternatively, you can link in an implementation of  main  written in Objective-C, common when incrementally migrating projects from Objective-C to Swift.   Global Variables   Given how Swift determines where to start executing an app, how should global variables work? In the following line of code, when should the initializer run?   [view code in blog]   In a single-file program, code is executed top-down, similar to the behavior of variables within a function.  Pretty simple. The answer for complex apps is less obvious, and we considered three different options:     Restrict initializers of global variables to be simple constant expressions, as C does.   Allow any initializer, run as a static constructor at app load time, as C++ does.   Initialize lazily, run the initializer for a global the first time it is referenced, similar to Java.     The first approach was ruled out because Swift doesn’t need constant expressions like C does. In Swift, constants are generally implemented as (inlined) function calls.  And there are good reasons to use complex initializers, e.g. to set up singletons or allocate a dictionary.   The second approach was ruled out because it is bad for the performance of large systems, as all of the initializers in all the files must run before the application starts up. This is also unpredictable, as the order of initialization in different files is unspecified.   Swift uses the third approach, which is the best of all worlds: it allows custom initializers, startup time in Swift scales cleanly with no global initializers to slow it down, and the order of execution is completely predictable.   The lazy initializer for a global variable (also for static members of structs and enums) is run the first time that global is accessed, and is launched as  dispatch_once  to make sure that the initialization is atomic.  This enables a cool way to use  dispatch_once  in your code: just declare a global variable with an initializer and mark it  private .   Summary   Swift is designed to make it easy to experiment in a playground or to quickly build a script. A complete program can be a single line of code. Of course, Swift was also designed to scale to the most complex apps you can dream up. With “main.swift” you can take complete control over initialization or you can let  @UIApplicationMain  do the startup work for you on iOS. </description>
            <pubDate>Fri, 01 Aug 2014 10:00:00 PDT</pubDate>
            <content:encoded><![CDATA[ <p>By now, most of you have written a small Swift app or experimented in the playground. You may even have experienced an error after you copied code from a playground into another file and wondered, “What is actually going on? What is the difference between a playground file, and other Swift source files?” This post will explain how Swift deals with the files in your project, and how global data is initialized.</p> <h3>Files in an App</h3> <p>A Swift app is composed of any number of files, each with the functions, classes, and other declarations that make up the app. Most Swift files in your app are <strong>order-independent</strong>, meaning you can use a type before it is defined, and can even import modules at the bottom of the file (although that is not recommended Swift style.)</p> <p>However, top-level code is not allowed in most of your Swift source files. For clarity, any executable statement not written within a function body, within a class, or otherwise encapsulated is considered top-level. We have this rule because if top-level code were allowed in all your files, it would be hard to determine where to start the program.</p> <h3>Playgrounds, REPL, and Top-Level Code</h3> <p>You may be wondering why the code below works perfectly in a playground. This example isn’t encapsulated in anything, so it must be top-level code:</p> <a href="http://developer.apple.com/swift/blog/?id=7">[view code in blog]</a> <p>The above single-line program works — with no additional code at all — because playground files do support the execution of top-level code. Code within a playground file is <strong>order-dependent</strong>, run in top-down lexical order. For example, you can’t use a type before you define it. Of course, Swift playground files can also define functions, classes, and any other legal Swift code, but they don’t need to.  This makes it easy to learn the Swift language or try a new API without writing a lot of code to get started.</p> <p>In addition to playgrounds, top-level code can also be run in the REPL (Read-Eval-Print-Loop) or when launching Swift files as scripts. To use Swift for scripting, you can use shebang-style launching by starting your Swift file with “#!/usr/bin/xcrun swift” or type “xcrun swift myFile.swift” within Terminal.</p> <h3>Application Entry Points and “main.swift”</h3> <p>You’ll notice that earlier we said top-level code isn’t allowed in <em>most</em> of your app’s source files. The exception is a special file named “main.swift”, which behaves much like a playground file, but is built with your app’s source code. The “main.swift” file can contain top-level code, and the order-dependent rules apply as well. In effect, the first line of code to run in “main.swift” is implicitly defined as the main entrypoint for the program. This allows the minimal Swift program to be a single line — as long as that line is in “main.swift”.</p> <p>In Xcode, Mac templates default to including a “main.swift” file, but for iOS apps the default for new iOS project templates is to add <span class="keyword">@UIApplicationMain</span> to a regular Swift file. This causes the compiler to synthesize a <span class="keyword">main</span> entry point for your iOS app, and eliminates the need for a “main.swift” file.</p> <p>Alternatively, you can link in an implementation of <span class="keyword">main</span> written in Objective-C, common when incrementally migrating projects from Objective-C to Swift.</p> <h3>Global Variables</h3> <p>Given how Swift determines where to start executing an app, how should global variables work? In the following line of code, when should the initializer run?</p> <a href="http://developer.apple.com/swift/blog/?id=7">[view code in blog]</a> <p>In a single-file program, code is executed top-down, similar to the behavior of variables within a function.  Pretty simple. The answer for complex apps is less obvious, and we considered three different options:</p> <ul class="numbered"> <li>Restrict initializers of global variables to be simple constant expressions, as C does.</li> <li>Allow any initializer, run as a static constructor at app load time, as C++ does.</li> <li>Initialize lazily, run the initializer for a global the first time it is referenced, similar to Java.</li> </ul> <p>The first approach was ruled out because Swift doesn’t need constant expressions like C does. In Swift, constants are generally implemented as (inlined) function calls.  And there are good reasons to use complex initializers, e.g. to set up singletons or allocate a dictionary.</p> <p>The second approach was ruled out because it is bad for the performance of large systems, as all of the initializers in all the files must run before the application starts up. This is also unpredictable, as the order of initialization in different files is unspecified.</p> <p>Swift uses the third approach, which is the best of all worlds: it allows custom initializers, startup time in Swift scales cleanly with no global initializers to slow it down, and the order of execution is completely predictable.</p> <p>The lazy initializer for a global variable (also for static members of structs and enums) is run the first time that global is accessed, and is launched as <span class="keyword">dispatch_once</span> to make sure that the initialization is atomic.  This enables a cool way to use <span class="keyword">dispatch_once</span> in your code: just declare a global variable with an initializer and mark it <span class="keyword">private</span>.</p> <h3>Summary</h3> <p>Swift is designed to make it easy to experiment in a playground or to quickly build a script. A complete program can be a single line of code. Of course, Swift was also designed to scale to the most complex apps you can dream up. With “main.swift” you can take complete control over initialization or you can let <span class="keyword">@UIApplicationMain</span> do the startup work for you on iOS.</p>]]></content:encoded>
        </item>
        <item>
            <title>Interacting with C Pointers</title>
            <link>http://developer.apple.com/swift/blog/?id=6</link>
            <guid>http://developer.apple.com/swift/blog/?id=6</guid>
            <description> Objective-C and C APIs often require the use of pointers. Data types in Swift are designed to feel natural when working with pointer-based Cocoa APIs, and Swift automatically handles several of the most common use cases for pointers as arguments. In this post we’ll look at how pointer parameters in C can be used with the variables, arrays, and strings in Swift.   Pointers as In/Out Parameters   C and Objective-C don’t support multiple return values, so Cocoa APIs frequently use pointers as a way of passing additional data in and out of functions. Swift allows pointer parameters to be treated like  inout  parameters, so you can pass a reference to a  var  as a pointer argument by using the same  &amp;  syntax. For instance,  UIColor ’s  getRed(_:green:blue:alpha:)  method takes four  CGFloat*  pointers to receive the components of the color. We can use  &amp;  to collect these components into local variables:   [view code in blog]   Another common case is the Cocoa  NSError  idiom. Many methods take an  NSError**  parameter to save an error in case of failure. For instance, we can list the contents of a directory using  NSFileManager ’s  contentsOfDirectoryAtPath(_:error:)  method, saving the potential error directly to an  NSError?  variable:   [view code in blog]   For safety, Swift requires the variables to be initialized before being passed with  &amp; . This is because it cannot know whether the method being called tries to read from a pointer before writing to it.   Pointers as Array Parameters   Pointers are deeply intertwined with arrays in C, and Swift facilitates working with array-based C APIs by allowing  Array  to be used as a pointer argument. An immutable array value can be passed directly as a  const  pointer, and a mutable array can be passed as a non- const  pointer argument using the  &amp;  operator, just like an  inout  parameter. For instance, we can add two arrays  a  and  b  using the  vDSP_vadd  function from the Accelerate framework, writing the result to a third  result  array:   [view code in blog]   Pointers as String Parameters   C uses  const char*  pointers as the primary way to pass around strings. A Swift  String  can be used as a  const char*  pointer, which will pass the function a pointer to a null-terminated, UTF–8-encoded representation of the string. For instance, we can pass strings directly to standard C and POSIX library functions:   [view code in blog]   Safety with Pointer Argument Conversions   Swift works hard to make interaction with C pointers convenient, because of their pervasiveness within Cocoa, while providing some level of safety. However, interaction with C pointers is inherently unsafe compared to your other Swift code, so care must be taken. In particular:     These conversions cannot safely be used if the callee saves the pointer value for use after it returns. The pointer that results from these conversions is only guaranteed to be valid for the duration of a call. Even if you pass the same variable, array, or string as multiple pointer arguments, you could receive a different pointer each time. An exception to this is global or static stored variables. You can safely use the address of a global variable as a persistent unique pointer value, e.g.: as a KVO context parameter.   Bounds checking is not enforced when a pointer to an  Array  or  String  is passed. A C-based API can’t grow the array or string, so you must ensure that the array or string is of the correct size before passing it over to the C-based API.    If you need to work with pointer-based APIs that don’t follow these guidelines, or you need to override Cocoa methods that accept pointer parameters, then you can work directly with raw memory in Swift using unsafe pointers. We’ll look at a more advanced case in a future post. </description>
            <pubDate>Mon, 28 Jul 2014 12:00:00 PDT</pubDate>
            <content:encoded><![CDATA[<p>Objective-C and C APIs often require the use of pointers. Data types in Swift are designed to feel natural when working with pointer-based Cocoa APIs, and Swift automatically handles several of the most common use cases for pointers as arguments. In this post we’ll look at how pointer parameters in C can be used with the variables, arrays, and strings in Swift.</p> <h3>Pointers as In/Out Parameters</h3> <p>C and Objective-C don’t support multiple return values, so Cocoa APIs frequently use pointers as a way of passing additional data in and out of functions. Swift allows pointer parameters to be treated like <span class="keyword">inout</span> parameters, so you can pass a reference to a <span class="keyword">var</span> as a pointer argument by using the same <span class="keyword">&amp;</span> syntax. For instance, <span class="keyword">UIColor</span>’s <span class="keyword">getRed(_:green:blue:alpha:)</span> method takes four <span class="keyword">CGFloat*</span> pointers to receive the components of the color. We can use <span class="keyword">&amp;</span> to collect these components into local variables:</p> <a href="http://developer.apple.com/swift/blog/?id=6">[view code in blog]</a> <p>Another common case is the Cocoa <span class="keyword">NSError</span> idiom. Many methods take an <span class="keyword">NSError**</span> parameter to save an error in case of failure. For instance, we can list the contents of a directory using <span class="keyword">NSFileManager</span>’s <span class="keyword">contentsOfDirectoryAtPath(_:error:)</span> method, saving the potential error directly to an <span class="keyword">NSError?</span> variable:</p> <a href="http://developer.apple.com/swift/blog/?id=6">[view code in blog]</a> <p>For safety, Swift requires the variables to be initialized before being passed with <span class="keyword">&amp;</span>. This is because it cannot know whether the method being called tries to read from a pointer before writing to it.</p> <h3>Pointers as Array Parameters</h3> <p>Pointers are deeply intertwined with arrays in C, and Swift facilitates working with array-based C APIs by allowing <span class="keyword">Array</span> to be used as a pointer argument. An immutable array value can be passed directly as a <span class="keyword">const</span> pointer, and a mutable array can be passed as a non-<span class="keyword">const</span> pointer argument using the <span class="keyword">&amp;</span> operator, just like an <span class="keyword">inout</span> parameter. For instance, we can add two arrays <span class="keyword">a</span> and <span class="keyword">b</span> using the <span class="keyword">vDSP_vadd</span> function from the Accelerate framework, writing the result to a third <span class="keyword">result</span> array:</p> <a href="http://developer.apple.com/swift/blog/?id=6">[view code in blog]</a> <h3>Pointers as String Parameters</h3> <p>C uses <span class="keyword">const char*</span> pointers as the primary way to pass around strings. A Swift <span class="keyword">String</span> can be used as a <span class="keyword">const char*</span> pointer, which will pass the function a pointer to a null-terminated, UTF–8-encoded representation of the string. For instance, we can pass strings directly to standard C and POSIX library functions:</p> <a href="http://developer.apple.com/swift/blog/?id=6">[view code in blog]</a> <h3>Safety with Pointer Argument Conversions</h3> <p>Swift works hard to make interaction with C pointers convenient, because of their pervasiveness within Cocoa, while providing some level of safety. However, interaction with C pointers is inherently unsafe compared to your other Swift code, so care must be taken. In particular:</p> <ul> <li>These conversions cannot safely be used if the callee saves the pointer value for use after it returns. The pointer that results from these conversions is only guaranteed to be valid for the duration of a call. Even if you pass the same variable, array, or string as multiple pointer arguments, you could receive a different pointer each time. An exception to this is global or static stored variables. You can safely use the address of a global variable as a persistent unique pointer value, e.g.: as a KVO context parameter.</li> <li>Bounds checking is not enforced when a pointer to an <span class="keyword">Array</span> or <span class="keyword">String</span> is passed. A C-based API can’t grow the array or string, so you must ensure that the array or string is of the correct size before passing it over to the C-based API.</li></ul> <p>If you need to work with pointer-based APIs that don’t follow these guidelines, or you need to override Cocoa methods that accept pointer parameters, then you can work directly with raw memory in Swift using unsafe pointers. We’ll look at a more advanced case in a future post.</p>]]></content:encoded>
        </item>
        <item>
            <title>Access Control</title>
            <link>http://developer.apple.com/swift/blog/?id=5</link>
            <guid>http://developer.apple.com/swift/blog/?id=5</guid>
            <description> In Xcode 6 beta 4, Swift adds support for access control. This gives you complete control over what part of the code is accessible within a single file, available across your project, or made public as API for anyone that imports your framework. The three access levels included in this release are:      private  entities are available only from within the source file where they are defined.    internal  entities are available to the entire module that includes the definition (e.g. an app or framework target).    public  entities are intended for use as API, and can be accessed by any file that imports the module, e.g. as a framework used in several of your projects.     By default, all entities have  internal  access. This allows application developers to largely ignore access control, and most Swift code already written will continue to work without change. Your framework code does need to be updated to define  public  API, giving you total control of the exposed interface your framework provides.   The  private  access level is the most restrictive, and makes it easy to hide implementation details from other source files. By properly structuring your code, you can safely use features like extensions and top-level functions without exposing that code to the rest of your project.   Developers building frameworks to be used across their projects need to mark their API as  public . While distribution and use of 3rd-party binary frameworks is not recommended (as mentioned in a previous blog post), Swift supports construction and distribution of frameworks in source form.   In addition to allowing access specification for an entire declaration, Swift allows the  get  of a property to be more accessible than its  set . Here is an example class that is part of a framework:   [view code in blog]   When mixing Objective-C and Swift, because the generated header for a framework is part of the framework’s public Objective-C interface, only declarations marked  public  appear in the generated header for a Swift framework. For applications, the generated header contains both  public  and  internal  declarations.    For more information,  The Swift Programming Language  and  Using Swift with Cocoa and Objective-C  books have been updated to cover access control.  Read the complete Xcode 6 beta 4 release notes here . </description>
            <pubDate>Wed, 23 Jul 2014 14:00:00 PDT</pubDate>
            <content:encoded><![CDATA[<p>In Xcode 6 beta 4, Swift adds support for access control. This gives you complete control over what part of the code is accessible within a single file, available across your project, or made public as API for anyone that imports your framework. The three access levels included in this release are:</p> <ul> <li><span class="keyword padding-left-0">private</span> entities are available only from within the source file where they are defined.</li> <li><span class="keyword padding-left-0">internal</span> entities are available to the entire module that includes the definition (e.g. an app or framework target).</li> <li><span class="keyword padding-left-0">public</span> entities are intended for use as API, and can be accessed by any file that imports the module, e.g. as a framework used in several of your projects.</li> </ul> <p>By default, all entities have <span class="keyword">internal</span> access. This allows application developers to largely ignore access control, and most Swift code already written will continue to work without change. Your framework code does need to be updated to define <span class="keyword">public</span> API, giving you total control of the exposed interface your framework provides.</p> <p>The <span class="keyword">private</span> access level is the most restrictive, and makes it easy to hide implementation details from other source files. By properly structuring your code, you can safely use features like extensions and top-level functions without exposing that code to the rest of your project.</p> <p>Developers building frameworks to be used across their projects need to mark their API as <span class="keyword">public</span>. While distribution and use of 3rd-party binary frameworks is not recommended (as mentioned in a previous blog post), Swift supports construction and distribution of frameworks in source form.</p> <p>In addition to allowing access specification for an entire declaration, Swift allows the <span class="keyword">get</span> of a property to be more accessible than its <span class="keyword">set</span>. Here is an example class that is part of a framework:</p> <a href="http://developer.apple.com/swift/blog/?id=5">[view code in blog]</a> <p>When mixing Objective-C and Swift, because the generated header for a framework is part of the framework’s public Objective-C interface, only declarations marked <span class="keyword">public</span> appear in the generated header for a Swift framework. For applications, the generated header contains both <span class="keyword">public</span> and <span class="keyword">internal</span> declarations.</p> <p> For more information, <a href="http://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/">The Swift Programming Language</a> and <a href="http://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/">Using Swift with Cocoa and Objective-C</a> books have been updated to cover access control. <a href="https://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_6_beta_4_o2p8fz/xcode_6_beta_4_release_notes.pdf">Read the complete Xcode 6 beta 4 release notes here</a>.</p>]]></content:encoded>
        </item>
        <item>
            <title>Building  assert()  in Swift, Part 1: Lazy Evaluation</title>
            <link>http://developer.apple.com/swift/blog/?id=4</link>
            <guid>http://developer.apple.com/swift/blog/?id=4</guid>
            <description> UPDATE: This post has been updated to reflect a change in Xcode 6 beta 5 that renamed  @auto_closure  to  @autoclosure , and  LogicValue  to  BooleanType .  When designing Swift we made a key decision to do away with the C preprocessor, eliminating bugs and making code much easier to understand. This is a big win for developers, but it also means Swift needs to implement some old features in new ways.  Most of these features are obvious (importing modules, conditional compilation), but perhaps the most interesting one is how Swift supports macros like  assert() .   When building for release in C, the  assert()  macro has no runtime performance impact because it doesn’t evaluate any arguments.  One popular implementation in C looks like this:   [view code in blog]   Swift’s assert analog provides almost all of the functionality of C’s assert, without using the preprocessor, and in a much cleaner way.  Let’s dive in and learn about some interesting features of Swift.   Lazy Evaluation of Arguments   When implementing  assert()  in Swift, the first challenge we encounter is that there is no obvious way for a function to accept an expression without evaluating it.  For example, say we tried to use:   [view code in blog]   Even when assertions are disabled, the application would take the performance hit of evaluating the expression:   [view code in blog]   One way we could fix this is by changing the definition of assert to take a closure:   [view code in blog]   This evaluates the expression only when assertions are enabled, like we want, but it leaves us with an unfortunate calling syntax:   [view code in blog]   We can fix this by using the Swift  @autoclosure  attribute.  The auto-closure attribute can be used on an argument to a function to indicate that an unadorned expression should be implicitly wrapped in a closure to the function.  The example then looks like this:   [view code in blog]   This allows you to call it naturally, as in:   [view code in blog]   Auto-closures are a powerful feature because you can conditionally evaluate an expression, evaluate it many times, and use the bound expression in any way a closure can be used.  Auto-closures are used in other places in Swift as well.  For example, the implementation of short-circuiting logical operators looks like this:   [view code in blog]   By taking the right side of the expression as an auto-closure, Swift provides proper lazy evaluation of that subexpression.   Auto-Closures   As with macros in C, auto-closures are a very powerful feature that must be used carefully because there is no indication on the caller side that argument evaluation is affected.  Auto-closures are intentionally limited to only take an empty argument list, and you shouldn’t use them in cases that feel like control flow. Use them when they provide useful semantics that people would expect (perhaps for a “futures” API) but don’t use them just to optimize out the braces on closures.   This covers one special aspect of the implementation of assert in Swift, but there is more to come. </description>
            <pubDate>Fri, 18 Jul 2014 11:00:00 PDT</pubDate>
            <content:encoded><![CDATA[<p class="update">UPDATE: This post has been updated to reflect a change in Xcode 6 beta 5 that renamed <span class="keyword">@auto_closure</span> to <span class="keyword">@autoclosure</span>, and <span class="keyword">LogicValue</span> to <span class="keyword">BooleanType</span>.</p><p>When designing Swift we made a key decision to do away with the C preprocessor, eliminating bugs and making code much easier to understand. This is a big win for developers, but it also means Swift needs to implement some old features in new ways.  Most of these features are obvious (importing modules, conditional compilation), but perhaps the most interesting one is how Swift supports macros like <span class="keyword">assert()</span>.</p> <p>When building for release in C, the <span class="keyword">assert()</span> macro has no runtime performance impact because it doesn’t evaluate any arguments.  One popular implementation in C looks like this:</p> <a href="http://developer.apple.com/swift/blog/?id=4">[view code in blog]</a> <p>Swift’s assert analog provides almost all of the functionality of C’s assert, without using the preprocessor, and in a much cleaner way.  Let’s dive in and learn about some interesting features of Swift.</p> <h3>Lazy Evaluation of Arguments</h3> <p>When implementing <span class="keyword">assert()</span> in Swift, the first challenge we encounter is that there is no obvious way for a function to accept an expression without evaluating it.  For example, say we tried to use:</p> <a href="http://developer.apple.com/swift/blog/?id=4">[view code in blog]</a> <p>Even when assertions are disabled, the application would take the performance hit of evaluating the expression:</p> <a href="http://developer.apple.com/swift/blog/?id=4">[view code in blog]</a> <p>One way we could fix this is by changing the definition of assert to take a closure:</p> <a href="http://developer.apple.com/swift/blog/?id=4">[view code in blog]</a> <p>This evaluates the expression only when assertions are enabled, like we want, but it leaves us with an unfortunate calling syntax:</p> <a href="http://developer.apple.com/swift/blog/?id=4">[view code in blog]</a> <p>We can fix this by using the Swift <span class="keyword">@autoclosure</span> attribute.  The auto-closure attribute can be used on an argument to a function to indicate that an unadorned expression should be implicitly wrapped in a closure to the function.  The example then looks like this:</p> <a href="http://developer.apple.com/swift/blog/?id=4">[view code in blog]</a> <p>This allows you to call it naturally, as in:</p> <a href="http://developer.apple.com/swift/blog/?id=4">[view code in blog]</a> <p>Auto-closures are a powerful feature because you can conditionally evaluate an expression, evaluate it many times, and use the bound expression in any way a closure can be used.  Auto-closures are used in other places in Swift as well.  For example, the implementation of short-circuiting logical operators looks like this:</p> <a href="http://developer.apple.com/swift/blog/?id=4">[view code in blog]</a> <p>By taking the right side of the expression as an auto-closure, Swift provides proper lazy evaluation of that subexpression.</p> <h3>Auto-Closures</h3> <p>As with macros in C, auto-closures are a very powerful feature that must be used carefully because there is no indication on the caller side that argument evaluation is affected.  Auto-closures are intentionally limited to only take an empty argument list, and you shouldn’t use them in cases that feel like control flow. Use them when they provide useful semantics that people would expect (perhaps for a “futures” API) but don’t use them just to optimize out the braces on closures.</p> <p>This covers one special aspect of the implementation of assert in Swift, but there is more to come.</p>]]></content:encoded>
        </item>
        <item>
            <title>Swift Language Changes in Xcode 6 beta 3</title>
            <link>http://developer.apple.com/swift/blog/?id=3</link>
            <guid>http://developer.apple.com/swift/blog/?id=3</guid>
            <description>  The Swift programming language continues to advance with each new Xcode 6 beta, including new features, syntax enhancements, and behavioral refinements. Xcode 6 beta 3 incorporates some important changes, a few of which we’d like to highlight:   Array has been completely redesigned to have full value semantics to match the behavior of Dictionary and String. Now a  let  array is completely immutable, and a  var  array is completely mutable.  Syntax “sugar” for Array and Dictionary has changed. Arrays are declared using  [Int]  as short hand for  Array&lt;&#x0200B;Int&#x0200B;&gt; , instead of  Int[] . Similarly, Dictionary uses  [Key: Value]  for  Dictionary&lt;&#x0200B;Key, Value&#x0200B;&gt; .  The half-open range operator has been changed from  ..  to  ..&lt;&#x0200B;  to make it more clear alongside the  ...  operator for closed ranges.    Xcode 6 beta is free to Registered Apple Developers and can be downloaded on the  Xcode downloads page . Read all about these and other changes in the complete  release notes for Xcode 6 beta 3.  </description>
            <pubDate>Tue, 15 Jul 2014 10:00:00 PDT</pubDate>
            <content:encoded><![CDATA[ <p>The Swift programming language continues to advance with each new Xcode 6 beta, including new features, syntax enhancements, and behavioral refinements. Xcode 6 beta 3 incorporates some important changes, a few of which we’d like to highlight:</p><ul><li>Array has been completely redesigned to have full value semantics to match the behavior of Dictionary and String. Now a <span class="keyword">let</span> array is completely immutable, and a <span class="keyword">var</span> array is completely mutable.</li><li>Syntax “sugar” for Array and Dictionary has changed. Arrays are declared using <span class="keyword">[Int]</span> as short hand for <span class="keyword">Array&lt;&#x0200B;Int&#x0200B;&gt;</span>, instead of <span class="keyword">Int[]</span>. Similarly, Dictionary uses <span class="keyword">[Key: Value]</span> for <span class="keyword">Dictionary&lt;&#x0200B;Key, Value&#x0200B;&gt;</span>.</li><li>The half-open range operator has been changed from <span class="keyword">..</span> to <span class="keyword">..&lt;&#x0200B;</span> to make it more clear alongside the <span class="keyword">...</span> operator for closed ranges.</li></ul> <p>Xcode 6 beta is free to Registered Apple Developers and can be downloaded on the <a href="https://developer.apple.com/xcode/downloads/">Xcode downloads page</a>. Read all about these and other changes in the complete <a href="https://developer.apple.com/library/prerelease/ios/releasenotes/DeveloperTools/RN-Xcode/">release notes for Xcode 6 beta 3.</a></p>]]></content:encoded>
        </item>
        <item>
            <title>Compatibility</title>
            <link>http://developer.apple.com/swift/blog/?id=2</link>
            <guid>http://developer.apple.com/swift/blog/?id=2</guid>
            <description> One of the most common questions we heard at WWDC was, “What is the compatibility story for Swift?”. This seems like a great first topic.   App Compatibility   Simply put, if you write a Swift app today and submit it to the App Store this Fall when iOS 8 and  OS X Yosemite  are released, you can trust that your app will work well into the future. In fact, you can target back to OS X Mavericks or  iOS 7  with that same app. This is possible because Xcode embeds a small Swift runtime library within your app’s bundle. Because the library is embedded, your app uses a consistent version of Swift that runs on past, present, and future OS releases.   Binary Compatibility and Frameworks   While your app’s runtime compatibility is ensured, the Swift language itself will continue to evolve, and the binary interface will also change. To be safe, all components of your app should be built with the same version of Xcode and the Swift compiler to ensure that they work together.   This means that frameworks need to be managed carefully. For instance, if your project uses frameworks to share code with an embedded extension, you will want to build the frameworks, app, and extensions together. It would be dangerous to rely upon binary frameworks that use Swift — especially from third parties. As Swift changes, those frameworks will be incompatible with the rest of your app. When the binary interface stabilizes in a year or two, the Swift runtime will become part of the host OS and this limitation will no longer exist.   Source Compatibility   Swift is ready to use today, in brand new apps or alongside your proven Objective-C code. We have big plans for the Swift language, including improvements to syntax, and powerful new features. And as Swift evolves, we will provide tools in Xcode to help you migrate your source code forward.   We can’t wait to see what you build! </description>
            <pubDate>Fri, 11 Jul 2014 10:00:00 PDT</pubDate>
            <content:encoded><![CDATA[<p>One of the most common questions we heard at WWDC was, “What is the compatibility story for Swift?”. This seems like a great first topic.</p> <h3>App Compatibility</h3> <p>Simply put, if you write a Swift app today and submit it to the App Store this Fall when iOS 8 and <span class="nowrap">OS X Yosemite</span> are released, you can trust that your app will work well into the future. In fact, you can target back to OS X Mavericks or <span class="nowrap">iOS 7</span> with that same app. This is possible because Xcode embeds a small Swift runtime library within your app’s bundle. Because the library is embedded, your app uses a consistent version of Swift that runs on past, present, and future OS releases.</p> <h3>Binary Compatibility and Frameworks</h3> <p>While your app’s runtime compatibility is ensured, the Swift language itself will continue to evolve, and the binary interface will also change. To be safe, all components of your app should be built with the same version of Xcode and the Swift compiler to ensure that they work together.</p> <p>This means that frameworks need to be managed carefully. For instance, if your project uses frameworks to share code with an embedded extension, you will want to build the frameworks, app, and extensions together. It would be dangerous to rely upon binary frameworks that use Swift — especially from third parties. As Swift changes, those frameworks will be incompatible with the rest of your app. When the binary interface stabilizes in a year or two, the Swift runtime will become part of the host OS and this limitation will no longer exist.</p> <h3>Source Compatibility</h3> <p>Swift is ready to use today, in brand new apps or alongside your proven Objective-C code. We have big plans for the Swift language, including improvements to syntax, and powerful new features. And as Swift evolves, we will provide tools in Xcode to help you migrate your source code forward.</p> <p>We can’t wait to see what you build!</p>]]></content:encoded>
        </item>
        <item>
            <title>Welcome to Swift Blog</title>
            <link>http://developer.apple.com/swift/blog/?id=1</link>
            <guid>http://developer.apple.com/swift/blog/?id=1</guid>
            <description> This new blog will bring you a behind-the-scenes look into the design of the Swift language by the engineers who created it, in addition to the latest news and hints to turn you into a productive Swift programmer.  Get started with Swift by downloading  Xcode 6 beta , now available to all Registered Apple Developers for free. The Swift Resources tab has a ton of great links to videos, documentation, books, and sample code to help you become one of the world’s first Swift experts. There’s never been a better time to get coding!  - The Swift Team  </description>
            <pubDate>Fri, 11 Jul 2014 10:00:00 PDT</pubDate>
            <content:encoded><![CDATA[<p>This new blog will bring you a behind-the-scenes look into the design of the Swift language by the engineers who created it, in addition to the latest news and hints to turn you into a productive Swift programmer.</p><p>Get started with Swift by downloading <a href="http://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_6_beta_3_lpw27r/xcode_6_beta_3.dmg" alt="">Xcode 6 beta</a>, now available to all Registered Apple Developers for free. The Swift Resources tab has a ton of great links to videos, documentation, books, and sample code to help you become one of the world’s first Swift experts. There’s never been a better time to get coding!</p><p>- The Swift Team </p>]]></content:encoded>
        </item>
        
    </channel>
</rss>